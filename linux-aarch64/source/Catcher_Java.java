/* autogenerated by Processing revision 1310 on 2025-12-26 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Catcher_Java extends PApplet {

int timeSeconds = 0;
int timeMinutes = 0;

boolean[] aus = new boolean[21];

enum StateOfGame {
    MENU,
    SETTINGS,
    GAME,
    PAUSE,
    RESET
};  

StateOfGame currentState = StateOfGame.MENU;

boolean startGame = false;
boolean stateGame = false;
boolean pauseGame = false;
boolean resetGame = false;
boolean endGame = false;
boolean darkwhite = true;

menu menuObject;
gameplay gameplayObject;
debugPanel debugPanelObject;

public void setup() {
  /* size commented out by preprocessor */;

  surface.setTitle("CATCH3R");
  surface.setResizable(false);

  /* smooth commented out by preprocessor */;
  
  menuObject = new menu();
  menuObject.setup();
  
  gameplayObject = new gameplay();
  gameplayObject.setup();

  debugPanelObject = new debugPanel();
  debugPanelObject.setup();
}

public void draw() {
  switch (currentState){
    case MENU:
      menuObject.draw();
      break;
    case SETTINGS:
      break;
    case GAME:
      gameplayObject.draw();
      break;
    case PAUSE:
      break;
    case RESET:
      break;
  }

  
  if (darkwhite == true) {
    fill = 255;
    backgr = 0;
  } else if (darkwhite == false) {
    fill = 0;
    backgr = 255;  
  }
}

public void mouseClicked()
{
  if (mouseButton == CENTER)
  {
    currentState = StateOfGame.PAUSE;
    textAlign(CENTER);
    textSize(30);
    fill(255);
    text("Press CMB or LMB to continue", width/2, height/2);
    if(mouseButton == CENTER && currentState == StateOfGame.PAUSE) {
      currentState = StateOfGame.GAME;
    }
  }

  menuObject.mouseClicked();
}

public void keyTyped() {

  if (currentState == StateOfGame.PAUSE) {
    if (key == ' ') {
      currentState = StateOfGame.GAME;
      if (currentState == StateOfGame.GAME) {
        gameplayObject.resetGame();
      }
    }
  }
  if (key == 't' || key == 'T') {
    darkwhite = !darkwhite;
  }
}

public void keyPressed() {
  playerObject.keyPressed();
  
  if (key == 'e' || key == 'E') {
    debugPanelObject.draw(); 
  }
}

public void keyReleased() {
  playerObject.keyReleased();
}

public void debugpanel() {
    println("-------------------");
    println("PlayerPos: (" + playerX + ", " + playerY + ")");
    println("CursePos: (" + curseX + ", " + curseY + ")");
    println("Curse speed: " + curseSp);
    println("Game run: " + startGame);
    println("Menu run: " + goMenu);
    println("Game pause:" + pauseGame);
    println("Game reset: " + resetGame);
    println("Game Over: " + endGame);
    println("Balls: " + ballcount);
    println("Bonus: " + goBonus);
    println("Curse: " + goCurse);
    println("Curse Type: " + curseStatus);
    println("-------------------");
}
public void drawgamepad(float x, float y) {
  
  noFill();
  strokeWeight(2);
  stroke(255, 0, 0);
  circle(x, y, 50);
  circle(x * 1.1f, y, 50);
}
float [] x = new float[21];
float [] y = new float[21];
float [] spX = new float[21];
float [] spY = new float[21];

float sz = 10;

int backgr = 0;

int fill = 255;

int[] col = new int[21];

int[] ballsn = new int[21];

class balls {

  public void setup() {

    ellipseMode(CENTER);

    for (int i = 1; i < ballsn.length; i++)
    {
      x[i] = random(constrain(( ((boxRight - boxMinHighlight) - sz / 2) - ((boxLeft + boxMinHighlight) + sz / 2)), (boxLeft + boxMinHighlight * 2) + sz, (boxRight - boxMinHighlight * 2) - sz));
      y[i] = random(constrain(( ((boxDown - boxMinHighlight) - sz / 2) - ((boxUp + boxMinHighlight) + sz/2)), (boxUp + boxMinHighlight * 2) + sz, (boxDown - boxMinHighlight * 2) - sz));

      aus[i] = true;
      col[i] = color(random(255), random(255), random(255));

      spX[i] = random(1, 5);
      spY[i] = random(1, 5);

      ballcount = i;
    }
  }

  public void draw()
  {
    noStroke();
    for (int i = 1; i < ballsn.length; i++)
    {

      if (aus[i])
      {
        fill(col[i]);

        x[i] += spX[i];
        y[i] += spY[i];

        circle(x[i], y[i], sz);

        if (x[i] + sz / 2 >= boxRight - boxMinHighlight|| x[i] - sz / 2 <= boxLeft + boxMinHighlight)
        {
          spX[i] = -spX[i];
        }
        if (y[i] + sz / 2 >= boxDown - boxMinHighlight || y[i] - sz / 2 <= boxUp + boxMinHighlight)
        {
          spY[i] = -spY[i];
        }
      }
    }
  }
}
float bonusX = 0, bonusY = 0, bonusMinSize = 5, bonusMaxSize = 20;

float bonusCol = 0;

float bonusStatus = 0;

boolean goBonus = false;

class bonus
{
  boolean grow = true;

  public void setup()
  {
    bonusX = constrain(random(width), 0 + bonusMaxSize, width - bonusMaxSize);
    bonusY = constrain(random(height), 0 + bonusMaxSize, height - bonusMaxSize);

    goBonus = true;
    bonusStatus = random(0, 2);
  }

  public void draw()
  {
    if (goBonus) {
      drawbonus();
      bonusEat();
    }
  }
  
  public void drawbonus() { 
    noStroke();
    fill(0, 255, 0);
    rectMode(CENTER);
    rect(bonusX, bonusY, bonusMinSize, bonusMinSize, 3);

    if (grow)
      {
        bonusMinSize += 0.2f;
      }
      if (bonusMinSize >= bonusMaxSize)
      {
        grow = false;
        bonusMinSize -= 0.2f;
      }
      if (bonusMinSize >= 5 && !grow)
      {
        bonusMinSize -= 0.2f;
      }
      if (bonusMinSize <= 5)
      {
        grow = true;
      }
      if (eatBonus(playerX, playerY, playerD, bonusX, bonusY, bonusMinSize))
      {
        goBonus = false;
      }
  }
  public void bonusEat() {
    if (eatBonus(playerX, playerY, playerD, bonusX, bonusY, bonusMinSize)){
      if (bonusStatus <= 1) {
        playerD = 80;
        counterTextSize = 28;
      } else if (bonusStatus <= 2) {
        playerSp = 8;
      }
    }
  }
}
public boolean menuMouse (float boxLeft, float boxRight, float boxUp, float boxDown)
{
  if (mouseX >= boxLeft &&
    mouseX <= boxRight - boxLeft &&
    mouseY >= boxUp &&
    mouseY <= boxDown - boxUp && !startGame)
  {
    return true;
  }
  return false;
}

public boolean OverButton(float ButtonX, float ButtonY, float ButtonMinWidth, float ButtonMinHeight) {
  if (mouseX >= ButtonX - ButtonMinWidth / 2 &&
    mouseX <= ButtonX + ButtonMinWidth / 2 &&
    mouseY >= ButtonY - ButtonMinHeight / 2 &&
    mouseY <= ButtonY + ButtonMinHeight / 2)
  {
    return true;
  }
  return false;
}

public boolean eat(float playerX, float playerY, float playerD, float x, float y, float sz)
{
  return playerX - playerD / 3 <= x + sz / 2 &&
    playerX + playerD / 3 >= x - sz / 2 &&
    playerY - playerD / 3 <= y + sz / 2 &&
    playerY + playerD / 3 >= y - sz / 2;
}

public boolean eatBonus(float playerX, float playerY, float playerD, float bonusX, float bonusY, float bonusMinSize)
{
  return playerX - playerD / 3 <= bonusX + bonusMinSize/ 2 &&
    playerX + playerD / 3 >= bonusX - bonusMinSize / 2 &&
    playerY - playerD / 3 <= bonusY + bonusMinSize / 2 &&
    playerY + playerD / 3 >= bonusY - bonusMinSize / 2;
}

public boolean eatСurse(float playerX, float playerY, float playerD, float curseX, float curseY, float curseMinSize)
{
  return playerX - playerD / 3 <= curseX + curseMinSize/ 2 &&
    playerX + playerD / 3 >= curseX - curseMinSize / 2 &&
    playerY - playerD / 3 <= curseY + curseMinSize / 2 &&
    playerY + playerD / 3 >= curseY - curseMinSize / 2;
}

public boolean playerOutOfBorder(float playerX, float playerY, float playerD, float boxLeft, float boxRight, float boxUp, float boxDown)
{
  if (startGame && playerX - playerD / 2 <= boxLeft ||
    playerX + playerD / 2 >= boxLeft + boxRight ||
    playerY - playerD / 2 <= boxUp ||
    playerY + playerD / 2 >= boxUp + boxDown) {
    return true;
  } else {
    return false;
  }
}
float boxLeft = 0, boxUp = 0, boxDown = 0, boxRight = 0;

float boxMinHighlight = 4;

float boxMaxHighlight = 10;

class border {

  public void setup() {

    boxRight = width;
    boxDown = height;
  }

  public void draw() {

    boxRight = width;
    boxDown = height;

    rectMode(CORNERS);
    stroke(fill);
    strokeWeight(boxMinHighlight);
    noFill();
    rect(boxLeft + boxMinHighlight / 4, boxUp + boxMinHighlight / 4, boxRight - boxMinHighlight / 4, boxDown - boxMinHighlight / 4);

    if (boxMinHighlight <= boxMaxHighlight && playerOutOfBorder(playerX, playerY, playerD, boxLeft, boxRight, boxUp, boxDown))
    {
      boxMinHighlight += 0.2f;
    } else if (boxMinHighlight == boxMaxHighlight) {
      boxMinHighlight -= 0.2f;
    } else if (boxMinHighlight >= 4 && !playerOutOfBorder(playerX, playerY, playerD, boxLeft, boxRight, boxUp, boxDown)) {
      boxMinHighlight -= 0.2f;
    }
  }
}
class Buttons {

  public void setup() 
  {
  
  }
  
  public void draw()
  {
  
  }
  
  public void createButton() 
  {
  
  }
  
  public void changeButton() 
  {
  
  }
}
class PlayerMovement extends player {
  
  
}
float curseX, curseY, curseMinSize = 5, curseMaxSize = 20, curseSp;

float curseCol = 0;

float dist = 0;

float curseStatus = 0;

boolean goCurse = false;

class curse
{
  boolean grow = true;

  public void setup() {
    curseX = constrain(random(width), 0 + curseMaxSize, width - curseMaxSize);
    curseY = constrain(random(height), 0 + curseMaxSize, height - curseMaxSize); 
    
    goCurse = true;
    curseStatus = PApplet.parseInt(random(1, 4));
  }

  public void draw() {
    if (currentState == StateOfGame.GAME && goCurse) {
      curseSp = playerSp * 0.5f;
      createcurse();
      playercinteract();
      curseEat();
    }
  }
  
  public void createcurse()
  {
      noStroke();
      fill(255, 0, 0);
      rectMode(CENTER);
      rect(curseX, curseY, curseMinSize, curseMinSize, 3);
      
      if (grow) {
        curseMinSize += 0.2f;
      }
      if (curseMinSize >= curseMaxSize) {
        grow = false;
        curseMinSize -= 0.2f;
      }
      if (curseMinSize >= 5 && !grow) {
        curseMinSize -= 0.2f;
      }
      if (curseMinSize <= 5) {
        grow = true;
      }
  }
  
  public void playercinteract()
  {
    if(currentState == StateOfGame.GAME) {
      
      float posX = playerX - curseX;
      float posY = playerY - curseY;
      
      dist = sqrt(sq(posX) + sq(posY));
      
      if (dist > 0){
        posX /= dist;
        posY /= dist;
        
        curseX += posX * curseSp;
        curseY += posY * curseSp;
      }
      else if(eatBonus(playerX, playerY, playerD, bonusX, bonusY, bonusMinSize) && playerSp == 8){
          curseSp = curseSp * 1.75f;
      }
    }
  }
  
  public void curseEat() 
  {
   if(eatСurse(playerX, playerY, playerD, curseX, curseY, curseMinSize)){
      if (curseStatus == 1) {
        playerD = 20;
        counterTextSize = 7;
      } 
      if (curseStatus == 2) {
        playerSp = 2;
      } 
      goCurse = false;
      if (curseStatus == 3) {
        setup();
        redraw();
      }
      //if (curseStatus == 4) {}
    }
  }
}
class debugPanel {
  
  int debugtextsize = 12;
  int debugtextcol = color(0, 255, 0);
  float x = 10;
  float y = 10;
  String empty;
  
  public void setup(){
  }
  
  public void draw(){
    drawDebugPanel();
  }
  
  public void drawDebugPanel() {
    fill(debugtextcol);
    textSize(debugtextsize);
    textAlign(LEFT);
    empty =
    "Player Pos: (" + round(playerX) + ", " + round(playerY) + ")\n" + 
    "Curse Pos: (" + round(curseX) + ", " + round(curseY) + ")\n" +
    "Curse Type: " + round(curseStatus) + "\n" +
    "Curse speed: " + round(curseSp) + "\n" +
    "Bonus Pos: (" + round(bonusX) + ", " + round(bonusY) + ")\n" +
    "Bonus Type: " + round(bonusStatus) + "\n" +
    "Game run: " + startGame + "\n" +
    "Menu run: " + goMenu + "\n" +
    "Game pause: " + pauseGame + "\n" +
    "Game reset: " + resetGame + "\n" +
    "Game Over: " + endGame + "\n" +
    "Bonus: " + goBonus + "\n" +
    "Curse: " + goCurse + "\n";
    
    text(empty, x + boxMaxHighlight, y + boxMaxHighlight);
  }
  
  public void drawDebugBack() {
  }
 }   
/*
            MUST:
1. ADD STATUSES FOR CURSES AND BONUSES  <- ACTUALLY HERE

2. ADD SOME EXTRA MOVEMENTS FOR PLAYER

3. ANIMATE MENU WITH BALLS

4. IMPROVE LOGIC OF CURSE AND BONUS

5. ADD CLOCK OF PLAYTIME

6. ADD SCORE OF PLAYTIME

7. ADD TABLE OF HICHSCORE

8. ADD ASSETS OF PLAYER

9. ADD ABILITY TO CHANGE PLAYER MODEL

10. ADD ADJUSTABLE SCREEN

11. MOVE VARIABLES IN CLASSES, IF IT CAN BE MOVED

12. ADD DEBUG PANEL ON KEY - COMPLETE
 
            MAYBE:
  IMPROVE LOGIC OF BALLS THAT THEY CAN MOVE MORE RANDOBLY

  RANDOM WALLS (RANDOM TIME)
*/

border borderObject;
bonus bonusObject;
curse curseObject;
player playerObject;
balls ballsObject;

class gameplay{

  public void setup() {
    borderObject = new border();
    borderObject.setup();
  
    bonusObject = new bonus();
    bonusObject.setup();
  
    curseObject = new curse();
    curseObject.setup();
  
    ballsObject = new balls();
    ballsObject.setup();
  
    playerObject = new player();
    playerObject.setup();
  }

  public void draw() {
    
    background(backgr);
    noStroke();

    textSize(24);
    textSize(15);
    text(ceil(frameRate), width/20, height / 20); 

    borderObject.draw();

    ballsObject.draw();
     
    curseObject.draw();

    bonusObject.draw();
 
    playerObject.draw();
    
    debugpanel();

    for (int i = 0; i < ballsn.length; i++)
    {
      if (aus[i] && eat(playerX, playerY, playerD, x[i], y[i], sz))
      {
        aus[i] = false;
        if (!aus[i])
        {
          ballcount--;
          if (ballcount == 0)
          {
            currentState = StateOfGame.PAUSE;
              if (currentState == StateOfGame.PAUSE){
                fill(fill);
                textSize(40);
                text("GameOver", width/2, height/3);
                textSize(30);
                text("Press SPACE to Restart", width/2, height/2);
              }
          }
        }
      }
    }
  }
  
  public void resetGame() {
    borderObject.setup();
    bonusObject.setup();
    curseObject.setup();
    playerObject.setup();
    ballsObject.setup();
  }
}
float nameX, nameY, nameBoxWidth, nameBoxHeight; 

float creditsX, creditsY, creditsBoxWidth, creditsBoxHeight;

float startButtonX, startButtonY,
      startButtonMinWidth, startButtonMaxWidth,
      startButtonMinHeight, startButtonMaxHeight,
      currentStartButtonWidth, currentStartButtonHeight;

float settingButtonX, settingButtonY,
      settingButtonMinWidth, settingButtonMaxWidth,
      settingButtonMinHeight, settingButtonMaxHeight,
      currentSettingButtonWidth, currentSettingButtonHeight;
  
float startTextMinSize, startTextMaxSize,
      currentStartTextSize;

float settingTextMinSize, settingTextMaxSize,
      currentSettingTextSize;

boolean goMenu = true;

boolean goSettings = false;

class menu {

  balls ballsObject;
  
  public void setup() {

    /* size commented out by preprocessor */;
    background(backgr);
    fill(fill);

    rectMode(CENTER);
    
    nameX = width / 2;
    nameY = height / 8;
    nameBoxWidth = width;
    nameBoxHeight = height / 8.5f;
    
    creditsX = width / 2;
    creditsY = height / 1.05f;
    creditsBoxWidth = width;
    creditsBoxHeight = height / 4;

    boxRight = width;
    boxDown = height;

    startButtonX = width / 2;
    startButtonY = height / 3;

    startButtonMinWidth = 100;
    startButtonMinHeight = 60;
    currentStartButtonWidth = startButtonMinWidth;
    currentStartButtonHeight = startButtonMinHeight;

    startButtonMaxWidth = startButtonMinWidth * 1.5f;
    startButtonMaxHeight = startButtonMinHeight + (startButtonMinHeight / 2.5f);

    startTextMinSize = 24;
    startTextMaxSize = 36;
    currentStartTextSize = startTextMinSize;

    settingButtonX = width / 2;
    settingButtonY = height / 2;

    settingButtonMinWidth = 100;
    settingButtonMinHeight = 60;
    currentSettingButtonWidth = settingButtonMinWidth;
    currentSettingButtonHeight = settingButtonMinHeight;

    settingButtonMaxWidth = settingButtonMinWidth * 1.5f;
    settingButtonMaxHeight = settingButtonMinHeight + (settingButtonMinHeight / 2.5f);

    settingTextMinSize = 24;
    settingTextMaxSize = 36;
    currentSettingTextSize = settingTextMinSize; 
    }

  public void draw() {
      background(backgr);
      drawName();
      drawStartButton();
      drawSettingsButton();
      drawCredits();
      
      if (menuMouse(boxLeft, boxRight, boxUp, boxDown)) {
        boxRight = width;
        boxDown = height;

        rectMode(CORNERS);
        stroke(fill);
        strokeWeight(boxMinHighlight);
        noFill();
        rect(boxLeft + boxMinHighlight / 4, boxUp + boxMinHighlight / 4, boxRight - boxMinHighlight / 4, boxDown - boxMinHighlight / 4);

        if (boxMinHighlight <= boxMaxHighlight && menuMouse(boxLeft, boxRight, boxUp, boxDown))
        {
          boxMinHighlight += 0.2f;
        } else if (boxMinHighlight == boxMaxHighlight) {
          boxMinHighlight -= 0.2f;
        } else if (boxMinHighlight >= 4 && !menuMouse(boxLeft, boxRight, boxUp, boxDown)) {
          boxMinHighlight -= 0.2f;
        }
      }
    }
  
  public void drawName(){
      rectMode(CENTER);
      fill(backgr);
      strokeWeight(4);
      rect(nameX, nameY, nameBoxWidth, nameBoxHeight);
  
      textAlign(CENTER, CENTER);
      textSize(40);
      fill(fill);
      text("CATCH3R", nameX, nameY);
  }
  
  public void drawCredits(){
      rectMode(CENTER);
      fill(backgr);
      strokeWeight(4);
      rect(creditsX, creditsY, creditsBoxWidth, creditsBoxHeight);
        
      textAlign(CENTER, CENTER);
      fill(fill);
      textSize(20);
      text("Made by sies-entert.\n No copyrights, just make fun", creditsX, creditsY - (creditsY / 15));
  }
  
  public void drawButton(float ButtonX, float ButtonY, float currentButtonWidth, float currentButtonHeight, float currentTextSize, String ButtonText) {
      rectMode(CENTER);
      strokeWeight(4);
      stroke(fill);
      noFill();
      rect(ButtonX, ButtonY, currentButtonWidth, currentButtonHeight, 2);

      textAlign(CENTER, CENTER);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              fill(fill);
      textSize(currentTextSize);
      text(ButtonText, ButtonX, ButtonY);
  }
  
  public void drawStartButton(){
      drawButton(startButtonX, startButtonY, currentStartButtonWidth, currentStartButtonHeight, currentStartTextSize, "Start"); 
      
      boolean hovering = OverButton(startButtonX, startButtonY, currentStartButtonWidth, currentStartButtonHeight);
      
      if (hovering) {
        if (currentStartButtonWidth < startButtonMaxWidth && 
            currentStartButtonHeight < startButtonMaxHeight && 
            currentStartTextSize < startTextMaxSize) {
          currentStartButtonWidth += 2.25f;
          currentStartButtonHeight += 1.25f;
          currentStartTextSize += 0.2f;
        }
      } else {
        if (currentStartButtonWidth > startButtonMinWidth || 
            currentStartButtonHeight > startButtonMinHeight || 
            currentStartTextSize > startTextMinSize) {
          currentStartButtonWidth -= 2.25f;
          currentStartButtonHeight -= 1.25f;
          currentStartTextSize -= 0.2f;
        }
      }
      currentStartButtonWidth = constrain(currentStartButtonWidth, startButtonMinWidth, startButtonMaxWidth);
      currentStartButtonHeight = constrain(currentStartButtonHeight, startButtonMinHeight, startButtonMaxHeight);
      currentStartTextSize = constrain(currentStartTextSize, startTextMinSize, startTextMaxSize);
   }
  
  public void drawSettingsButton() {
      drawButton(settingButtonX, settingButtonY, currentSettingButtonWidth, currentSettingButtonHeight, currentSettingTextSize, "Settings"); 
      boolean hovering = OverButton(settingButtonX, settingButtonY, currentSettingButtonWidth, currentSettingButtonHeight);
      
      if (hovering) {
        if (currentSettingButtonWidth < settingButtonMaxWidth && 
            currentSettingButtonHeight < settingButtonMaxHeight && 
            currentSettingTextSize < settingTextMaxSize) {
          currentSettingButtonWidth += 2.25f;
          currentSettingButtonHeight += 1.25f;
          currentSettingTextSize += 0.2f;
        }
      } else {
        if (currentSettingButtonWidth > settingButtonMinWidth || 
            currentSettingButtonHeight > settingButtonMinHeight || 
            currentSettingTextSize > settingTextMinSize) {
          currentSettingButtonWidth -= 2.25f;
          currentSettingButtonHeight -= 1.25f;
          currentSettingTextSize -= 0.2f;
        }
      }
      currentSettingButtonWidth = constrain(currentSettingButtonWidth, settingButtonMinWidth, settingButtonMaxWidth);
      currentSettingButtonHeight = constrain(currentSettingButtonHeight, settingButtonMinHeight, settingButtonMaxHeight);
      currentSettingTextSize = constrain(currentSettingTextSize, settingTextMinSize, settingTextMaxSize);
  }

  public void mouseClicked() {
    if (OverButton(startButtonX, startButtonY, currentStartButtonWidth, currentStartButtonHeight) && mouseButton == LEFT) {
      currentState = StateOfGame.GAME;
    }

    if (OverButton(settingButtonX, settingButtonY, currentSettingButtonWidth, currentSettingButtonHeight) && mouseButton == LEFT) {
      currentState = StateOfGame.SETTINGS;
    } 
  }
}
float playerX = 0, playerY = 0, playerD = 0, playerSp = 0;

float counterX = 0, counterY = 0, counterTextSize = 0;

int ballcount = 0;
boolean leftPressed = false;
boolean rightPressed = false;
boolean upPressed = false;
boolean downPressed = false;

class player
{
  public void setup() {
    playerX = width/2;
    playerY = height/2;
    playerD = 40;
    playerSp = 4;
    counterTextSize = 14;

    playerX = constrain(playerX, (boxLeft + boxMinHighlight / 2) + playerD / 2, (boxRight - boxMinHighlight / 2) - (playerD / 2));
    playerY = constrain(playerY, (boxUp + boxMinHighlight / 2) + playerD / 2, (boxDown - boxMinHighlight / 2) - (playerD / 2));

    counterX = playerX;
    counterY = playerY;
  }

  public void draw() {

    counterX = playerX;
    counterY = playerY;

    fill(fill);
    textSize(counterTextSize);
    strokeWeight(4);
    textAlign(CENTER, CENTER);
    text(ballcount, counterX, counterY);

    noFill();
    stroke(fill);
    strokeWeight(2);
    circle(playerX, playerY, playerD);

    if (leftPressed) {
      playerX -= playerSp;
      if (playerX <= boxLeft + boxMinHighlight / 2) {
        playerX = boxRight - boxMinHighlight / 2;
      }
    }
    if (rightPressed) {
      playerX += playerSp;
      if (playerX >= boxRight - boxMinHighlight / 2) {
        playerX = boxLeft + boxMinHighlight / 2;
      }
    }
    if (upPressed) {
      playerY -= playerSp;
      if (playerY <= boxUp + boxMinHighlight / 2) {
        playerY = boxDown  - boxMinHighlight / 2;
      }
    }
    if (downPressed) {
      playerY += playerSp;
      if (playerY >= boxDown - boxMinHighlight / 2) {
        playerY = boxUp + boxMinHighlight / 2;
      }
    }
  }

  public void keyPressed() {
    if (keyCode == LEFT || key == 'a' || key == 'A') {
      leftPressed = true;
    }
    if (keyCode == RIGHT || key == 'd' || key == 'D') {
      rightPressed = true;
    }
    if (keyCode == UP || key == 'w' || key == 'W') {
      upPressed = true;
    }
    if (keyCode == DOWN || key == 's' || key == 'S') {
      downPressed = true;
    }
  }

  public void keyReleased() {
    if (keyCode == LEFT || key == 'a' || key == 'A') {
      leftPressed = false;
    }
    if (keyCode == RIGHT || key == 'd' || key == 'D') {
      rightPressed = false;
    }
    if (keyCode == UP || key == 'w' || key == 'W') {
      upPressed = false;
    }
    if (keyCode == DOWN || key == 's' || key == 'S') {
      downPressed = false;
    }
  }
  
}
class PlayerStatus extends player{
  
  public void setup() {

  }
  
  public void draw() {
  
  }
}


  public void settings() { size(400, 600);
smooth(10); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Catcher_Java" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
